# Introduction to Computer Science
## 第1章
### 1.1 试着解释1.5节中两个重要思想中的第一个。
最快的计算机能完成的事情，最慢的计算机也一样能完成，只是更慢一点。
### 1.2 试问，同汇编语言相比，高级语言是否能像底层计算机表述更多的计算方式？
不能，高级语言与底层计算机的相关性很弱（距离很远），
低级语言和执行程序的计算机紧密相关，通常一种低级语言只对应一种计算机。
我们称之为“某某及其的汇编语言”。
### 1.3 试问，是什么原因使得模拟计算机难以实现，从而使设计这转向采用数字实现。
难以提高其精度。数字机通过一组固定的，有限的数字和自负完成操作。
### 1.4 列举自然语言的特性之一，说明他为什么不适合直接作为编程语言？
二义性。没有足够的确定性。
### 1.5 通过加法器和乘法器制作：
1. ax+b
2. 四个输入w，x，y，z的平均值。
3. a平方+2ab+b平方
### 1.6 试用自然语言写一句话，然后给出这句话可能的两种解释。
谁不喜欢毛爷爷：1.毛爷爷指人民币。2.毛爷爷指某不可描述人物。
### 1.7 前文中有关抽象的讨论。如果“底层所有一切都很好”，我们是没有必要去了解不见组成。如果情况并不良好，我们还是要学会分解部件。解释什么情况下这种方法是有效的，在什么情况下会起到反作用。
设计电路时不需要理解门电路的详细排布组成，因为他们是可靠的，有效的。即是，工具可靠，可用时，不需要去关注细枝末节。只要你输入a他高效地提供给你想要的b即可。
如果他无法提供给你想要的B，才应该去修改细枝末节，修改门电路，修改MOS管。
### 1.8 "I saw a man with a telescope"。这意味着什么？这句话有过多少种解释。这句话具备什么特性，使得它如果出现在程序中是无法接受的。
1. 两种解释，1是，我看一个拿着望远镜的男人；2是，我用望远镜看见一个男人。
2. 二义性。
### 1.9 自然语言可以表达算法吗
可以。可以通过自然语言，流程图以及伪代码等进行表示。
自然语言的优势是易懂。
### 1.10 给出算法的三个特性，并给出简单的解释
1. 确定性（definiteness）表示每个操作步骤的描述是清晰的，可定义的。
2. 可计算性（effective computability)。表示每个步骤的描述都可被计算机执行。
3. 有限性（finiteness）。即过程是会终止的。
### 1.11 针对算法的每个特性，分别给出一个例子，在例子代码中，都缺少这个特性。说明此时为什么不能说它是一个算法。
### 1.12 以下a到e是否是算法？
1. a.是
2. b.缺少有限性
3. c.是
4. d.是
5. e.是
### 1.13 两台计算机A和B，除了A具有剑法指令外，其他指令完全相同。两者都具有对一个数求负值的指令。试问：A和B两台计算机，哪一台能解决的问题更多？证明你的结论。
一样多。减法指令可以通过加法指令即减数的负数进行计算。
### 1.14 
1. 120种
### 1.15 将高级语言和底层语言相比较，列举一个优点一个缺点。
1. 高级语言：接近自然语言，易懂，但是与底层计算机相关性很弱。
2. 低级语言：与底层计算机相关性强，但是难懂
### 1.16 列举至少三个ISA定义所包含的内容。
操作数，数据类型和寻址模式
### 1.17 简答描述ISA和微结构之间的区别。
ISA是使用者能够使用的类似于接口的东西，微结构是这个接口的具体实现，是接口背后的东西。
### 1.18 一种微结构可以实现多少种ISA？再反问，一种ISA可以在多少种微结构上实现？
一种微结构可以实现一种ISA。一种ISA可以在无数多种微结构上实现。
### 1.19 列举转换过程中的所有层次，并在每层找一个例子。
问题（从大到小排列）->算法（冒泡算法）->语言（C语言）->机器结构（X86）->微结构（奔腾4）->电路（全加器）->器件（CMOS）
### 1.20 1.6的转换层次又被称为是不同的抽象层次。你认为这种说法是否合理？
合理，在机器结构完全可靠，可以不去了解它如何实现，去使用它。
### 1.21 假设你去商店购买字处理软件。请问该软件通常以什么方式存在？是高级语言方式或事汇编语言？或是与你的计算机ISA兼容的格式？请回答。
应该是与计算机ISA兼容的格式。
### 1.22 加入给你一个人物，完成图1-6中某一层的转换工作，且只军需转换为下面的一层。你觉得哪一层的转换工作难度最大，为什么？
电路转化为器件，工作量大
### 1.23 为什么通常会不断改变微结构实现，却不改变ISA？例如，intel公司为什么要确保奔腾3所实现的ISA一定要与之前的奔腾2一样？
为了保证兼容性。毕竟intel不是apple。但apple也不可能一年整一个新M1芯片是吧。
## 第二章
### 2.1 一个n-bit数可以表示多少个不同的二进制数？
2的n次方。
### 2.2 如果采用二进制bit串来表示英语中的26个字母，至少需要多少个bit？如果还要区分大小写字母，又要多少bit？
5位，大小写区分要6位
### 2.3
1. a.假设某班级有400个学生，如果我们位没个学生分配一个惟一的二进制bit串，那么至少需要多少个bit来表示所有的学生？
9位，共计512个
2. b.如果不再增加bit数，这个班最多还能增加多少个学生？
112
### 2.4 给定n位（bit），它可以表示多少个不同的无符号的整数？范围是多大？
0到2的n次方-1
### 2.5 如果用5-bit表示数值，写出数值7和-7分别对应的反码，符号位码，补码表示方式。
|类别|7|-7|
|---|---|---|
|反码|00111|11000|
|符号位码|00111|10111|
|补码|00111|11001|
### 2.6 试用6-bit反码表示数值-32
6-bit的32是010000，反码是101111。
### 2.7 试列出4-bit二进制补码所能表示的所有整数。
15到-16
### 2.8 
1. a.8-bit二进制补码能表示的最大正整数是多少？分别写出十进制和二进制。
127 0111111
2. b.8-bit二进制补码能表示的具有最大绝对值的复数是多少？分别写出十进制和二进制数。
-128 10000000
3. c.n-bit 二进制补码能表示的最大正整数是多少？
2的n次方的二分之一-1
4. d.n-bit二进制补码所能表示的具有最大绝对值的复数是多少？
负的n次方的二分之一
### 2.9 如果用二进制补码方式表示摩尔常数6.0X10的23次方，需要多少个bit？
32bit
### 2.10 将下面的二进制补码转换为十进制
1. a.1010=-6
2. b.01011010 = 90
3. c.11111110 = -2
4. d.0011100111010011=14803
### 2.11 将下面的十进制转换为8bit二进制补码：
1. a.102 = 01100111
2. b. 64 = 01000000
3. c. 33 = 00100001
4. d. -128 =10000001
5. e. 127 = 01111111
### 2.12 二进制补码最后一位如果是0，那么这个数必然是偶数。如果二进制补码的最后两位都是0（例如二进制数01100），那么这种数有什么特点。
0000 = 0, 0100 = 4, 1000 = 8, 1100 = 12，能够被4整除。
### 2.13 请假下面的二进制改写为8bit数，且不允许改变其原有数值。
1. a. 1010 = 11111010
2. b. 011001 = 00011001
3. c. 1111111000 = 11111000
4. d.01 = 00000001
### 2.14 计算下裂二进制加法，结果仍然表示为二进制数。
1. a. 1011+0001 = 1100
2. b. 0000 + 1010 = 1010
3. c. 1100 + 0011 = 1111
4. d. 0101 + 0110 = 1011
5. e.1111+ 0001 = 10000
### 2 .15 在本章例2-5中，证明了一个二进制数左移一位等价于将该数值乘2，试问，如果将其右移一位，等价于什么操作呢。
除以2
### 2.16 计算以下8-bit加法的结果，并分别写出结果所对应的二进制和十进制数。
1. a.7的反码加上-7的反码
00000111+11111000=00000000
7+-7=0
2. b.7的符号位表示加上-7的符号位表示。
00000111+10000111 = 10001110
3. c.7的补码加上-7的补码
00000111+11111001 = 00000000
### 2.17 计算以下无符号二进制数的加法，并将结果转换为十进制形式。
1. a. 01+1011 =1100
